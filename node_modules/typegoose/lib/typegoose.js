"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
const mongoose = require("mongoose");
const _ = require("lodash");
const data_1 = require("./data");
__export(require("./method"));
__export(require("./prop"));
__export(require("./hooks"));
__export(require("./plugin"));
var utils_1 = require("./utils");
exports.getClassForDocument = utils_1.getClassForDocument;
class Typegoose {
    getModelForClass(t, { existingMongoose, schemaOptions, existingConnection } = {}) {
        const name = this.constructor.name;
        if (!data_1.models[name]) {
            const Schema = mongoose.Schema;
            const sch = schemaOptions ?
                new Schema(data_1.schema[name], schemaOptions) :
                new Schema(data_1.schema[name]);
            const staticMethods = data_1.methods.staticMethods[name];
            sch.statics = staticMethods;
            const instanceMethods = data_1.methods.instanceMethods[name];
            sch.methods = instanceMethods || {};
            if (data_1.hooks[name]) {
                const preHooks = data_1.hooks[name].pre;
                preHooks.forEach((preHookArgs) => {
                    sch.pre(...preHookArgs);
                });
                const postHooks = data_1.hooks[name].post;
                postHooks.forEach((postHookArgs) => {
                    sch.post(...postHookArgs);
                });
            }
            if (data_1.plugins[name]) {
                _.forEach(data_1.plugins[name], (plugin) => {
                    sch.plugin(plugin.mongoosePlugin, plugin.options);
                });
            }
            const getterSetters = data_1.virtuals[name];
            _.forEach(getterSetters, (value, key) => {
                if (value.get) {
                    sch.virtual(key).get(value.get);
                }
                if (value.set) {
                    sch.virtual(key).set(value.set);
                }
            });
            let model = mongoose.model.bind(mongoose);
            if (existingConnection) {
                model = existingConnection.model.bind(existingConnection);
            }
            else if (existingMongoose) {
                model = existingMongoose.model.bind(existingMongoose);
            }
            data_1.models[name] = model(name, sch);
            data_1.constructors[name] = this.constructor;
        }
        return data_1.models[name];
    }
}
exports.Typegoose = Typegoose;
//# sourceMappingURL=typegoose.js.map